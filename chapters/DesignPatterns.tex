
一般来说，我们需要修改的现有代码越少，设计的可改动性就越大：
需要修改的代码越少，意味着需要做的工作就越少（效率），犯错误的可能性就越小（有效性）。
我们需要处理的地方更少（切换-效率），犯错误的机会更少（有效性）。

\paragraph{可变性应当是固定的}如果设计没有改变，其可变性也不应当改变。这意味着可变性应该与我们想要实施的具体更改无关。换句话说，无论我们要进行的更改有多大，现有设计的可变性应该是相同的。例如，无论是为井字游戏添加图形用户界面还是仅仅将`X'改为`x'和`0'改为`o'，现有设计的可变性都应该相同。

\paragraph{可变性与新增代码的数量无关}实际上，这意味着可变性不应依赖于必须编写的新代码数量。但是，什么是新代码？

在现有代码行中添加代码？ — 这是对现有代码行的更改。

在现有方法中添加完整的代码行？ — 这是对现有方法的更改。

添加新方法？ — 这是对现有类的更改。

添加新的内嵌类？ — 这是对现有类的更改。

添加枚举？ — 如果是内嵌的，则是对现有类的更改。

添加枚举？ — 如果是新文件，则是新的。

新接口？ — 如果是新文件，则是新的。

新类？ — 如果是新文件，则是新的。

\paragraph{评估可变性时应忽略新文件}换句话说，当考虑设计的可变性时，我们应该关注对现有设计元素的更改，而不是完全新的添加。如果在添加新功能的时候完全没有改动旧代码，那就太好了。

\section*{量化可更改性}
\subsubsection{CR值}
CR 通过比较预期的变更影响（I）和实际必须更改的类或文件的数量来评估可变性。理想情况下，如果一个系统是高度可维护的，对于一个给定的变更，需要更改的文件数量应该是最小化的。
\[\displaystyle CR = \frac{C}{N}\]
其中，N 是现有设计中的类（或文件）总数。
C 是实现变更案例时需要更改的类（或文件）数量。

如果 $CR \approx I$，变更成本与预期一致。
如果 $CR > I$，则变更成本高于预期，表明系统的可变性较低（即更难修改）。
如果 $CR < I$，则变更成本低于预期，表明系统的可变性较高（即更易修改）。

\subsubsection{降低CR值--增加N}
千方百计添加类来增加N（look for excuses to add classes!）。这可能涉及对系统进行更细粒度的分解，每个类都有一个非常特定的责任。

\subsubsection{降低CR值--减少C}
强调尽可能在新的类中添加新代码，而不是更改现有的类。这种策略有助于保持现有代码的稳定性，同时允许扩展和修改。

\subsubsection{局限性}
CR是一个针对特定变更案例的度量标准，它不能全面地代表一个设计的整体可变性。一个设计在某一特定变更案例下可能表现出低CR（即高可变性），但在另一个变更案例下可能就表现出高CR（即低可变性）。

实际的变更案例是无限的，所以我们无法确保已经考虑了所有可能的变更案例。这在某种程度上限制了CR度量的全面性和预测性。

当系统规模庞大（例如，类的数量以千计）时，未实际进行变更之前，很难准确地确定需要变更的类的数量（C），这进一步增加了使用CR的复杂性。

模型是相当粗粒度的，因为它不考虑更改的方法或语句。这意味着，即使更改影响到了多个类，如果每个类只需要很小的更改，CR 也可能高估了实际变更成本。

考虑到这些局限性，建议在做设计决策时，寻找能够在可能发生的、具有实质性影响的变更案例下最小化CR的设计。应该避免那些CR高度依赖于特定变更案例的设计，因为这种设计的可变性更难以预测和管理。寻找能减少需要变更的类的数量的设计，或者在保持需要变更的类数量不变的情况下增加总类数量的设计。这可能涉及到更细粒度的模块化，或者更好的封装和抽象。
对任何设计，都应该思考可能引起问题的变更案例，并尝试预测和规划这些情况。这样的前瞻性思考可以帮助创建一个更具弹性和适应性的系统设计。

\chapter{Design Patterns}
