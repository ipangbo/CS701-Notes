\chapter{OOD}

很多关于“OO”的讨论主要集中在语言的特性上。
是否可以独立于任何编程语言来讨论面向对象设计？
这是一个深入的问题。从纯理论的角度看，面向对象的原则和概念（如封装、继承和多态）是独立于具体语言的。但在实际应用中，某些语言的特性可能会影响或指导面向对象设计的实践。
我们必须具备哪些为OO语言讨论的特性？
这个问题留给读者去思考。常见的OO语言特性包括封装、继承、多态和抽象。但是，不同的人可能会对这些特性有不同的看法，取决于他们的经验和使用的语言。


\section{面向对象编程的基本特性}
\begin{itemize}
    \item 对象：面向对象编程的核心是对象，它们表示现实世界中的事物或概念，并具有属性和方法。
    \item 封装：封装是将数据（属性）和对该数据的操作（方法）包装在一起的概念。封装隐藏了对象的内部表示，并仅通过对象的接口暴露其行为。这提到了“封装了什么？”的问题，答案是“对象”。
    \item 类：类是创建对象的模板或蓝图。但是，不是所有被认为是OOP的语言都有类的概念，例如Self和JavaScript，它们使用基于原型的继承。
    \item 继承：继承允许新的类继承现有类的属性和方法。但这提出了一个问题：“什么是继承？”。例如，Emerald语言中的继承可能与其他语言中的继承有所不同。
    \item 类型：类型定义了一组值和这些值上的操作。例如，Smalltalk是一种动态类型语言，这意味着它在运行时检查类型，而不是在编译时。
    \item 泛型类型：泛型类型允许编程人员为一个类定义多种数据类型。这在Smalltalk中可能不太明显，而在Java的早期版本中，泛型是不存在的。
    \item 多态：多态允许不同的类的对象通过同样的接口进行交互。它也被称为虚函数调用、动态调度或消息发送。
\end{itemize}

仅仅使用一个具有面向对象特性的语言并不意味着你正在进行面向对象的编程。真正的OOP需要遵循某些设计原则和模式，而不仅仅是使用某种具有OOP特性的语言。

当执行面向对象程序时，它会创建相互发送消息的对象。面向对象设计描述了一个面向对象程序的设计或结构。

\subsection{面向对象设计的后果和影响}
封装：封装是对象间交互只能通过消息发送而产生的结果。这意味着，直接访问对象的字段或属性并不是面向对象的，因为真正的面向对象交互应该通过消息传递来完成。
继承：继承本身并不是决定一个程序是否为面向对象的关键，但它对设计质量有很大的影响。主要的原因是继承可以避免代码的重复，提高代码的重用性。
类型：类型的存在主要是为了防止某些类型的错误，例如变量的类型错误。
静态成员：静态成员不是面向对象设计的一部分，因为它们不属于特定的对象实例，而是属于类。
\textbf{类：类是用来描述和创建对象的。类是面向对象设计中的蓝图或模板，用于创建对象。}

因此，决定应该有哪些对象是创建一个可维护的面向对象设计的基础。换句话说，为了创建一个成功和可维护的OOD，开发者首先需要确定他们想要在系统中表示的实体或对象。

\section{类}
“类”是面向对象范式的核心概念。
类是面向对象设计的基础。
大多数自称为“面向对象”的编程语言都有某种形式的“类”结构。

设计过程中需要做的决策之一是决定包含哪些类。
类的选择确实会影响设计的可维护性。
为什么？类定义了系统的主要结构和行为。一个合理、结构化且有意义的类选择可以增加代码的可读性、可理解性和可扩展性，从而提高整体的可维护性。

\subsection{可维护的类}
\subsubsection{可理解性}
选择与我们已知知识相关的类会更容易理解。我们更容易理解与我们现实生活经验或已知领域知识相符的概念。所以，类应当与待解决问题的实际上下文有关，这样它们就会“有意义”。
\subsubsection{可变性}
为一个变更案例需要改动的越少，工作量就越小。在设计时考虑未来的可能变动并创建灵活性高的类可以降低未来维护的成本和风险。例如，如果一个类的功能高度集中且与其他部分的耦合度(coupling degree)低，那么它就更容易进行修改。
\subsubsection{可测试性}
如果可以更容易地查看和控制当前状态，那么测试的效率就会更高。设计类时应考虑到未来的测试需求，确保可以方便地访问和修改它们的状态。

\section{对象}
\subsection{对象的基本特性}
\begin{itemize}
    \item 身份 (Identity)：每个对象都有一个独特的身份，区别于其他对象。
    \item 状态 (State)：对象具有描述其当前条件或信息的属性。
    \item 行为 (Behaviour)：对象可以执行的功能或方法。
\end{itemize}

\subsection{对象间的交互}
对于一个对象来说，想要向另一个对象发送消息，它必须有某种方法来识别那个对象。这里的“识别”即涉及到了对象的“身份”。
发送消息的真正价值在于接收方对象如何回应该消息，以及基于其历史或状态的响应方式。这里包含了两个重要概念：
响应或行为：当一个对象收到消息后，它会如何行动或响应，这涉及到“行为”这一特性。

历史或状态对象的当前状态或之前的历史状态可能会影响其对消息的响应。例如，一个关闭的窗户对象收到“打开”消息时的响应与一个已经打开的窗户对象收到同样的消息时的响应是不同的。这涉及到“状态”这一特性。

\subsection{可维护的对象}
不是所有对象都适合解决特定问题，因此，选择恰当的对象非常重要。Arthur J. Riel的启示是“尽可能模拟现实世界”。这意味着，设计应该基于真实世界的实体和关系。这可以使设计更有意义，更易于理解。Christensen的方法是首先确定行为（责任），然后将它们分组成角色，定义角色之间的协作模式，最后确定可以扮演这些角色的对象。这提供了一个从抽象到具体的结构化方法，从行为的责任到实现这些责任的具体对象。Booch提到对象是现实世界实体的抽象，代表了特别的“密度和内聚”的信息集群。换句话说，好的对象设计应当内聚，并且相关信息应当集中。Barnes和Kölling的建议是查看需求或描述，然后识别名词和动词。名词通常对应于类和对象，而动词对应于对象的行为或方法。这提供了一个直观的方法来从需求中提取设计元素。\textbf{设计的对象应该真实地反映它们所代表的现实世界实体的行为。这样可以确保设计与实际需求保持一致。}

当对象与真实世界中的某些东西对应时，如果我们已经知道这部分真实世界（它存在于我们的知识库中），那么这些对象将更容易理解。这减少了为理解代码意图而花费的时间和努力。如果对象代表真实世界中的实体，并且这个实体没有发生变化，那么这些对象也不应该改变。这种一致性确保代码的稳定性和可靠性。如果对象与真实世界中的某物相对应，那么我们应该能够像在真实世界中那样测试它们。这使得验证代码行为变得更为直观和实用。

\subsubsection{创建好的对象}

并非描述中的所有名词都对应于我们需要构建的东西。例如，描述中的“维基百科关于Kalah的文章”并不意味着需要一个与Wikipedia或Kalah文章相对应的对象。

在设计中，可能会出现一些不是任何需求描述部分的合理 sounding objects，例如HashMap。这些通常是为了实现某些功能或性能需求而引入的。

所有建议都指向选择与要解决的问题有关的对象。选择与问题域紧密相关的对象可以提高代码的可读性、可维护性和可扩展性。

\subsubsection{Context Schema}
Context schema 指的是设计者对问题上下文的所有认知和信仰。换句话说，这是设计者关于问题背景的心智模型或视觉。例如，提到了“Noughts and Crosses”是在一个3x3的网格上进行的。这提供了一个清晰的上下文，帮助我们理解游戏的基本规则和环境。

上下文模式为设计师提供了一个基本的框架或参考，帮助他们了解和描绘问题的背景。只有充分了解上下文，设计师才能有效地开展工作并制定相应的策略。
\subsubsection{Design Schema}
Design Schema 是关于可能的设计构件的多样性的所有认知，包括设计决策和候选解决方案。这是设计者关于设计对象及其可选方案的心智模型。例如，设计者知道下拉菜单是一种为用户提供选择的紧凑方式。这种认知来自于过去的经验或学习，告诉设计者如何在特定上下文中提供用户界面选择。

设计模式为设计者提供了一种方法，帮助他们认识到不同的设计元素、策略和解决方案。这种模式可以指导设计师如何在给定的上下文中选择最佳的设计策略。

一个好的面向对象设计应该包含与上下文模式相关的对象（show respect to the context schema)。当类更接近于上下文模式或设计模式中的概念时，它的可维护性会更好。设计中的类若能紧密匹配现实世界的概念和设计者的认知，那么在未来对这个类的维护和理解就会更加直观和简单。如何确定一个类“正确地”匹配了一个概念？匹配的一个方面是，创建的对象数量应该符合预期。这意味着，当我们设计一个类，并在程序中实例化它，那么这个类的实例数量应该是可预测和合理的。