\chapter{Classes}

类应 "表示 "上下文模式或设计模式中的 "概念"。在编程中，概念通常指的是可以被建模和表示的实体或行为。如果一个类能够清晰、准确地捕获某个概念的核心属性和行为，并且没有多余的、不相关的信息，那么我们可以说这个类“代表”了这个概念。

\section{Martin on Classes}
\subsection{Organization}
一种基本的组织顺序如下：
\begin{itemize}
    \item ublic static final fields (constants):
          常量经常用于定义与类关联的固定值或配置。将它们置于顶部可以方便地看到这些重要的固定值，无需在代码中搜索。
    \item other static fields:
          这些字段通常与类级别的状态或配置有关，而与实例无关。与常量一起放在顶部，读者可以清楚地看到与整个类相关的信息。

    \item instance fields:
          实例字段是与特定对象实例相关的状态。放在静态字段后面，它们为后面的方法提供了上下文，因为这些方法可能会操作这些字段。

    \item Constructors:
          构造函数是用于初始化对象的方法。在实例字段之后放置它们是有意义的，因为构造函数通常会设置这些字段的值。

    \item public methods:
          公共方法定义了类的公共接口，即其他类或对象如何与其交互。它们应该根据其重要性或调用频率进行排序。

    \item non-public methods (but those called by public methods close to the methods they're called from):
          非公共方法通常是辅助方法或实现细节。它们应该被放置在被调用的公共方法附近，这样读者在阅读公共方法时可以轻松地找到它们。对于protected与private之间的排序，考虑到protected可能被子类使用，可以考虑将其置于private方法之前。
\end{itemize}

使用这种顺序的原因（仅供参考）：

逻辑流程：此顺序遵循从一般到特定的逻辑流程。首先是与整个类相关的静态内容，然后是与实例相关的内容。

阅读流：开发者通常首先关注公共接口，即公共方法。将它们放在前面可以确保他们不必滚动到文件的末尾来查找这些方法。

聚焦核心功能：公共方法通常定义了类的核心功能，而私有方法提供了实现这些功能所需的辅助功能。将公共方法置于前面有助于突出显示核心功能。

易于维护：当你需要修改或添加一个功能时，相关的代码通常在彼此附近，这减少了在文件中搜索相关代码的时间。

\subsection{Encapsulation}

对象（及其所属的类）代表上下文或设计方案中出现的概念或抽象。在面向对象编程中，对象是现实世界概念的模型或表示。
字段描述对象的状态。这是对象的内部属性，它决定了对象在特定时间点的行为和特性。

封装的主要目的是隔离类的内部实现细节，使得外部代码不能直接访问或修改它。这样做的一个重要原因是，当内部实现发生变化时，不会影响到使用这个类的其他代码。私有字段和实用程序方法是这种隔离的关键组成部分。直接访问对象的实现细节或其内部状态是不良的设计选择。这是因为：
如果实现者更改了内部表示，那么所有直接使用它的事物都必须也进行更改，这会导致维护上的噩梦。
直接暴露实现细节会导致代码之间的强耦合，降低灵活性。

封装确实提高了代码的可理解性，因为开发者可以更加集中地理解对象的核心功能，而不是被其内部工作机制所干扰。
同时，封装也是可维护性的关键。当实现细节被封装，更改它们不会对使用该类的其他部分产生不良影响。

当我们希望子类能够访问或覆盖某个字段或方法时，受保护的可见性是可以接受的。尽管这为子类提供了更多的灵活性，但它也增加了父类和子类之间的耦合，这可能会降低代码的维护性。

公共字段可以被任何外部代码直接访问和修改，这违反了封装的原则。此外，公共字段不允许对其访问或修改进行任何形式的控制，例如数据验证。

有时，我们确实需要访问对象的某些内部值或状态，但关键是如何做到这一点。优秀的设计通常通过提供公共的getter和setter方法来实现这一点，这些方法可以控制对内部状态的访问和修改，而不是直接暴露字段。

用字段和方法的可见性来解释 "良好封装 "是不够的：封装不仅仅是关于字段和方法的可见性。它也关系到如何组织代码、如何定义类和对象之间的交互以及如何管理依赖关系。只关注可见性可能会忽略这些更深入的考虑。

将字段和实用方法私有化：

安全性：私有字段和方法只能被类自己使用，这意味着开发者不必担心外部代码错误地使用或修改它们。

清晰的接口：当字段和实用方法被设为私有时，类的公共接口会更清晰，因为它只显示真正需要被外部代码调用的方法。

简化的变更管理：由于内部实现细节被封装起来，修改这些细节时不需要担心会对其他部分的代码产生不良影响。

提高代码的可读性：将实现细节隐藏起来，开发者可以更加集中注意力于类的核心功能和行为，而不是分散在诸多的细节中。

\subsubsection{封装与可理解性}

对象在编程中代表特定的概念或实体。例如，Money 和 Card 分别代表了金钱和卡片这两个概念。当我们考虑一个特定的概念时，我们通常对该概念的行为有一定的期望。因此，当对象的行为与我们的期望不符时，可能会导致理解上的问题。如果对象的行为与我们的期望产生偏差，那么这会影响到我们对代码的理解。

在这个例子中，我们通常不期望Money对象中的dollars和cents字段的值会频繁改变。但是，由于这些字段被设置为公开，因此它们的值有可能被外部改变，从而导致潜在的理解问题。

在这个例子中，isFaceUp字段可能需要被外部访问和修改，以反映卡片是否面朝上的状态。由于我们可能期望这个字段的值会改变，所以将其设置为公开可能不会导致太大的理解问题。然而，尽管如此，这可能会影响到其他维护性方面。

\subsubsection{访问器与封装}

常常有人建议为了确保“正确的封装”，应该将字段设置为私有，并提供访问器函数（即getters和setters）。仅仅通过getters（和setters）提供对字段的访问并不保证适当的封装。封装不仅仅是隐藏数据，而是确保数据的整合性和对象的行为与我们的期望一致。如果getter提供的信息是关于数据的内部表示而不支持类所应代表的抽象，那么这种getter就会“破坏封装”。如果getter允许对象的行为与该对象所应代表的概念的期望行为不一致，那么这种getter也会“破坏封装”。设计问题不应该只是“是否应该提供getters和/或setters”。真正的问题是，为了支持所需的抽象，需要哪些方法？如果这些方法恰好是getters或setters，那么可以提供它们。

\subsection{Small}
Martin建议类应该尽可能小，并且第二条规则强调它们应该比你认为的还要小。Martin没有具体指出，如果类不小，会发生什么不好的事情。但在编程和设计中，经常有这样的智慧，即简单和简洁往往与可维护性和可理解性成正比。

对于对象（及其类）来说，如果它不代表上下文模式或设计模式中的概念，那么设计的可理解性就会降低。

一个类可能无法代表一个概念的方式之一是，它实际上代表了多个概念。当一个类试图做太多事情或代表太多不同的概念时，它可能变得复杂和难以维护。越小的类更有可能与单一的概念相匹配。小类更有可能是专注的、具有单一责任，并因此更易于理解和维护。

\subsection{Single Responsibility Principle, SRP}
SRP是由Martin及其他人推广的所谓的"SOLID"原则之一。SOLID原则是面向对象程序设计的五大原则，其中"S"代表单一职责原则。按照SRP，一个类应该只有一个职责。然而，这里并没有明确指出“职责”的具体定义，这可能是因为职责的定义可能会因上下文或具体应用而异。SRP还指出，一个类应该只有一个变更的原因。这意味着，如果业务需求或其他外部因素发生变化，影响到类的结构或行为，那么这个类应该只因为一个原因进行修改。这有助于确保类的稳定性和可维护性。遵循SRP的类很可能是小类。这是有道理的，因为一个只承担一个职责的类不太可能包含大量的方法或属性。小类也更有可能是清晰的、专注的，并更易于维护。

对于一个类：

字段(Field):

\_cents 和 \_dollars: 这两个私有字段分别表示货币的“分”和“元”部分。这些字段的私有性保证了它们不会在类的外部被直接修改，符合封装原则。

构造函数(Constructor):

用于初始化\_cents和\_dollars的值。构造函数通常不被认为是类的“职责”或“原因”。
方法(Methods):

toString(): 返回货币的标准字符串表示。

formalString(): 返回带有货币符号（NZD）的正式字符串表示。

这两个方法都与货币的展示相关，但呈现的格式不同。

Money类代表了一个主要的概念——货币。从功能上看，它有一个主要职责：表示和展示货币的值。尽管类中有两个方法，但它们都围绕着货币的表示这一核心职责。具体来说，两个方法提供了两种不同的字符串表示方式，但都是为了展示货币的值。因此，我们可以说类有一个主要的职责，即展示货币，但有多种方式来实现这一职责。

更改货币值的表示方式（例如，仅表示总的“分”数量）
这种更改只影响内部数据的表示，而不会改变类的外部行为或它的主要责任。换句话说，无论内部如何表示货币，类的主要功能（即表示和显示货币）都保持不变。
更改字符串的格式
虽然toString()和formalString()方法可以独立地修改字符串的格式，但这些修改并不会根本改变类的主要职责。它仍然是为了展示货币的值，只是展示的方式有所不同。
将货币代码从NZD更改为AUD
这种修改会改变类的外部行为，因为它影响了货币的表示方式。货币单位是货币价值的一个重要组成部分，因此，更改货币代码确实会改变类所做的事情。
将符号从“\$”更改为“e”
和货币代码的修改类似，这种更改也会改变类的外部行为。不过，“e”通常代表欧元，所以这种更改可能会使Money类的语境变得模糊。在此情境中，符号的更改确实影响了类的功能，尤其是当我们考虑到不同货币符号可能与特定的货币代码或货币类型关联时。

\subsection{Cohesion}
\paragraph{内聚性}是一个描述模块内部元素之间关联程度的度量。它描述了模块或类的各个组成部分执行同一任务所需的程度。换句话说，如果模块或类中的所有部分都为单一目的或功能服务，那么它被认为具有高内聚性。

一个模块或类的各个部分越是紧密地联系在一起，它就越容易理解。当元素之间的绑定不够紧密，即内聚性较低时，模块变得难以理解。因此，高内聚性通常被视为一种优良的设计特性。

内聚性经常与“耦合性”相提并论。耦合性描述了模块或类与其他模块或类之间的交互程度。理想的情况是，一个模块或类应该有高内聚性和低耦合性，这意味着它应该有一个清晰定义的目的（高内聚性），同时与其他模块或类的交互应该尽可能少（低耦合性）。

一个具有单一职责的类具有高内聚性。当一个类专注于一个特定的任务或功能时，它的内部元素（如字段和方法）通常都是为该任务或功能服务的，因此它们之间的关联度很高。如果一个类有许多字段和方法，但每个方法只使用其中的一小部分字段，那么这个类的内部元素之间可能没有很强的关联，这意味着该类的内聚性可能较低。

\section{总结}
为了帮助理解，我们需要与上下文和设计模式中的概念相匹配的类。
封装意味着对象的实际行为方式与其所代表的概念一致。
有多种短语可用于描述匹配良好的对象： 具有良好对象的类往往是 "小 "的（对于 "小 "的定义）。