\section{2022 Test 1 Notes}

对于每道题，请先写一遍题目中提到的定义。

\subsection{Q2}
\subsubsection{a}
软件维护的种类：corrective, adaptive, preventative, perfective。
增加一个特性是perfective。
\subsubsection{b 讨论可变性：}
可更改性是指如何在不引入缺陷或降低现有产品质量的前提下，有效且充分地更改产品系统。
4.3 中有很多地方需要修改，而 5.1 中的修改只有第 14、61、62 和 64 行（后三行都在一个方法 changePlayer() 中）。因此，仅仅修改 4.3 就需要更多的工作（\textbf{效率更低}）。

由于要修改的地方较多，而每个地方都有可能出错（例如漏掉），因此要修改的地方越多，出错的可能性就越大（假设出错的可能性差不多--在本例中是一样的，因为在两种实现中要做的修改是一样的）。由于 4.3 需要改动的地方较多，在改动时出错的几率也较高，因此\textbf{有效性}较低。

提示：可变性与可理解性互相独立。本题中请不要讨论可理解性。

\subsection{Q3 类的大小/数量如何影响测试性}
比较：

小的类会比大的多（因为功能是一样的）。假设每个类都能提供相同水平的可观察性和可控制性，这意味着小的将比大的拥有更多的可观察性和可控制性，因此更容易测试。

事实上，小类可能比大类更具可观察性和可控性。类越大，需要为测试正确设置的状态就越多（Controllability），需要查看（Observability）的东西就越多，以便在测试后确认类中的对象是正确的。也就是说，需要花费更多精力来进行测试，这就不如小类的效率(Efficiency)高。

有单一责任（SRP）的类通常比没有单一责任的类小。

当一个类依赖于另一个类时（例如，通过调用另一个类中对象的方法），测试该类就需要额外的工作来设置另一个类中的对象。小类更有可能不依赖于其他类，因此所需的工作量会更少（Efficiency）。

\subsection{Q4 PCM}
\subsubsection{解释KB中的知识的特性}

这种知识优势必须存在（在知识库中），以便能够理解任何代码，但这种知识并不具体涉及所理解的代码。

String result = obj.someMethod(); 例如，对于这段代码：我们将使用 Java 语法知识来认识到 someMethod() 必须返回字符串（假设代码能编译）。知识库中的这些知识类似于 "当赋值运算符 (=) 右侧有一个方法调用，左侧有一个 java.lang.String 类型的变量时，该方法必须返回一个 String 值"。这不是专门关于代码的知识，因此不会出现在 MM 中。
MM 中的知识应该是这样的："变量 obj 来自 A 类，A 类中的方法 someMethod() 返回一个描述对象当前状态的字符串"。

\subsubsection{解释陌生代码如何内化}
这段代码位于 ER 中。理解这段代码需要 Java 方面的知识，尤其是 = 左边和右边的含义。此外，还需要了解方法调用语法和方法调用的含义。这些知识与代码本身无关（见第(a)部分），因此必须放在知识库中。
如果您没有相关的 Java 知识，也就是说知识库中没有这些知识，那么您就需要获取这些知识。这就需要查阅有关 Java 的描述，这些描述可以在 ER 中找到。一旦掌握了这些知识，它们就会出现在知识库中。
一旦掌握了必要的 Java 知识，您就可以通过 AP 来解释代码（在 ER 中），从而确定代码的作用，并根据这些新信息更新 MM。

请注意，需要引用模型中的每一个组件。