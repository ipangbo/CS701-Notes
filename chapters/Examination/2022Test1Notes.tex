\section{2022 Test 1 Notes}

对于每道题，请先写一遍题目中提到的定义。

\subsection{Q2}
\subsubsection{a}
软件维护的种类：corrective, adaptive, preventative, perfective。
增加一个特性是perfective。
\subsubsection{b 讨论可变性：}
可更改性是指如何在不引入缺陷或降低现有产品质量的前提下，有效且充分地更改产品系统。
4.3 中有很多地方需要修改，而 5.1 中的修改只有第 14、61、62 和 64 行（后三行都在一个方法 changePlayer() 中）。因此，仅仅修改 4.3 就需要更多的工作（\textbf{效率更低}）。

由于要修改的地方较多，而每个地方都有可能出错（例如漏掉），因此要修改的地方越多，出错的可能性就越大（假设出错的可能性差不多--在本例中是一样的，因为在两种实现中要做的修改是一样的）。由于 4.3 需要改动的地方较多，在改动时出错的几率也较高，因此\textbf{有效性}较低。

提示：可变性与可理解性互相独立。本题中请不要讨论可理解性。

\subsection{Q3 类的大小/数量如何影响测试性}
比较：

小的类会比大的多（因为功能是一样的）。假设每个类都能提供相同水平的可观察性和可控制性，这意味着小的将比大的拥有更多的可观察性和可控制性，因此更容易测试。

事实上，小类可能比大类更具可观察性和可控性。类越大，需要为测试正确设置的状态就越多（Controllability），需要查看（Observability）的东西就越多，以便在测试后确认类中的对象是正确的。也就是说，需要花费更多精力来进行测试，这就不如小类的效率(Efficiency)高。

有单一责任（SRP）的类通常比没有单一责任的类小。

当一个类依赖于另一个类时（例如，通过调用另一个类中对象的方法），测试该类就需要额外的工作来设置另一个类中的对象。小类更有可能不依赖于其他类，因此所需的工作量会更少（Efficiency）。

\subsection{Q4 PCM}
\subsubsection{解释KB中的知识的特性}

这种知识优势必须存在（在知识库中），以便能够理解任何代码，但这种知识并不具体涉及所理解的代码。

String result = obj.someMethod(); 例如，对于这段代码：我们将使用 Java 语法知识来认识到 someMethod() 必须返回字符串（假设代码能编译）。知识库中的这些知识类似于 "当赋值运算符 (=) 右侧有一个方法调用，左侧有一个 java.lang.String 类型的变量时，该方法必须返回一个 String 值"。这不是专门关于代码的知识，因此不会出现在 MM 中。
MM 中的知识应该是这样的："变量 obj 来自 A 类，A 类中的方法 someMethod() 返回一个描述对象当前状态的字符串"。

\subsubsection{解释陌生代码如何内化}
这段代码位于 ER 中。理解这段代码需要 Java 方面的知识，尤其是 = 左边和右边的含义。此外，还需要了解方法调用语法和方法调用的含义。这些知识与代码本身无关（见第(a)部分），因此必须放在知识库中。
如果您没有相关的 Java 知识，也就是说知识库中没有这些知识，那么您就需要获取这些知识。这就需要查阅有关 Java 的描述，这些描述可以在 ER 中找到。一旦掌握了这些知识，它们就会出现在知识库中。
一旦掌握了必要的 Java 知识，您就可以通过 AP 来解释代码（在 ER 中），从而确定代码的作用，并根据这些新信息更新 MM。

请注意，需要引用模型中的每一个组件。

\subsection{Q5 可读性}

\subsubsection{a 可读性如何影响可理解性}
识别元素（如循环体）或区分元素（如一个变量与另一个变量）或确定哪些元素属于同一个元素越困难，阅读就越困难。 如果阅读困难，那么理解的效果和/或效率就会降低。因此，可读性低就意味着可理解性低。

\subsubsection{b 巨量代码空白如何影响可理解性}
卫生间管道提示建议不要让多个函数的代码同时出现在屏幕上。每行之间有多个空行可能会降低可理解性，因为读者需要上下滚动屏幕来阅读和理解一个功能。如果阅读一个功能需要时间，那么从 ER 到 KB/MM 的内化过程就会延长。从而影响理解一个功能的效果和效率。


\subsection{Q6 四连棋游戏}

\subsubsection{a 棋子类是否必要}

为玩家投放到网格中的物品（从现在起将称为 "令牌"）引入一个类别会增加理解该类别所需的额外工作。

不过，我们可以考虑另一种方法。必须要有一些代码来显示网格中是否有标记物。这些代码至少需要记录它属于哪个玩家，可能还需要记录它的颜色。每次有人查看这段代码时，他们都必须记住这段代码在做什么。

可维护性的定义（及其所有方面）适用于整个生命周期内的整个实现。因此，虽然在第一次查看类的代码时需要付出额外的努力，但预计在大多数情况下，这些代码都不会再被查看。从长远来看，该类的成本可能与查看备用代码并记住其含义的成本相差不大。

此外，如果需要对令牌进行任何更改（可更改性），如果有一个类，那么所需的努力将仅限于更改该类。如果只有一些代码，那么该代码存在的每个地方（例如，检查行中哪个位置未填写的代码、检查是否有中奖行的代码）都必须更改。这种工作量（效率）可能远远超过仅仅更改类的工作量。

我们需要的主要方法是一个能确定由哪位玩家出牌的方法（例如类似 getColour()的方法）。在真实游戏（上下文模式）中，没有什么能阻止玩家交换他们使用的颜色）。

\subsubsection{b “棋子”还是“令牌” - PCM}
一个类与上下文或设计模式中所代表的概念越一致，就越容易理解。鉴于问题中对游戏的描述总是提到 "令牌"，这似乎比任何其他选择（包括 "棋子"）都更好。

\textbf{The more a class is consistent with the concept it represents from the context or design schema, the more comprehensible it will be.}

\subsubsection{c 什么是正确的对象数量}

在现实世界的游戏中，必须至少有 42 个代币（网格中最多有 42 个地方可以放置代币）。据推测，游戏在出售时还会附带一些备用代币，以防代币丢失。无论总共有多少代币，它们在游戏开始时都是存在的。
在软件中，我们不必担心代币丢失的问题（假设），因此这表明至少应该创建 42 个代币，以获得与上下文模式的最佳匹配。
但在软件中，我们不需要一开始就准备好所有计划使用的东西，因为我们可以根据需要创建它们（假设）。在本例中，将为所示示例创建 14 个标记。

\subsubsection{d 再确定2个实体类}

例如：Grid、Player、Connect4、Column（或类似名称）： 网格、玩家、Connect4、列（或类似名称）。位置（或类似名称）可能是不需要的（与 "Noughts and Crosses "游戏不同，玩家并不选择网格中的特定位置，而只是选择列），但允许使用。
与 Noughts and Cross 不同，玩家不会选择网格中的特定位置，只会选择列），但可以使用。
对于这种情境模式来说，"棋盘"（Board）不是一个好名字，因为在描述中使用了 "网格 "一词（而且使用的也不是通常意义上的 "棋盘"）。


\subsection{Q7 封装如何支持可维护性}
封装用于支持类所代表的抽象，尤其是如何管理内部状态。如果一个类的设计允许内部状态以与抽象不一致的方式发生变化，则表明封装存在问题。

如图所示的类是用来表示玩家在 "十进制 "游戏中选择的移动位置。一旦玩家做出了选择，就不能更改（上下文模式）。设置器方法（setRow() 和 setCol()）的存在使得坐标对象所代表的位置可以更改。这与上下文模式的预期不一致，因此 "破坏了封装"。

类中的每个方法都会为理解它带来代价。如果这种代价是不必要的，就像 "坐标 "类中的 setter 方法一样，那么就会降低理解它的效率(Efficiency)，从而降低可理解性。可理解性是可维护性的一个方面，因此这意味着可维护性会降低。

如果使用 setter 方法，就有可能错误地改变坐标对象的状态，从而产生故障(Effectiveness)。

注意，虽然获取器对于 "坐标 "所代表的抽象来说并不是必需的，但它们并不会改变对象的状态，因此问题不大（仍有可比性代价）。然而，它们的存在确实为类提供了可观察性，这将有助于可测试性，因此在这种情况下需要权衡利弊。请注意，构造函数支持可控性，因此不需要设置器来实现可控性。

\subsection{Q8 减少缩进层级对可理解性的影响}

可理解性是指理解代码过程的效率和效果。然而，评估可理解性不应局限于一次性查看代码。它必须在代码的整个生命周期中进行评估。

就问题中的两个版本而言，虽然重构后的版本确实 "有更多的代码"，但要正确评估可理解性，就必须考虑这些额外代码在整个生命周期中的影响。如果每次查看 checkDraw() 方法时都要查看额外的代码，那么就会增加成本，因此重构版本的效率较低，可理解性也较低。

但是，通过选择新方法的名称（isRowFull），我们希望在第一次读取该方法后，在查看 checkDraw() 方法时再也不用查看它。然而，在原始代码中，"如果 (\_grid[row][col] == '')，代码是怎么回事？"每次都会被问到，而且回答这个问题要比查看 isRowFull() 方法的调用花费更多精力。因此，总体而言，重构代码将降低成本，从而提高可理解性。
