\chapter{Test Driven Development}

创建软件涉及到许多决策，这些决策可能关乎软件架构、设计模式、算法选择、数据结构、代码风格等。理想情况下，开发者总是希望做出正确的决策，以确保软件的高质量和长期的可维护性。启发式可以为开发者在面临决策时提供指导。例如，设计原则、最佳实践或其他经验法则。
然而，即使有了这样的指导，仍然存在一些决策难以作出，因为它们可能涉及到多个交叉关注点或因项目特定的约束而变得复杂。

鉴于上述的挑战，需要一个通常（或至少经常）有助于做出良好决策的过程。

\section{测试驱动开发}

TDD是一个软件开发过程，其中开发者首先为一个新的功能或修复写下一个失败的测试，然后写代码使测试通过，最后重构代码以达到所需的标准。在TDD中，开发是由已经写好的测试指导的。这意味着在实际编写功能代码之前，开发者已经明确了期望的行为和输出。为了让测试能够执行，设计必须支持测试。这意味着，代码结构、模块划分和依赖关系等都需要被设计成易于测试的。

\subsubsection{具体步骤}

\begin{itemize}
	\item \textbf{添加一个小测试：}选择一个能够让现有实现失败的测试。
	\item \textbf{运行所有测试：}确保新添加的测试失败。
	\item \textbf{做一个小改动：}只修改足够使新的测试通过的代码，这一阶段不需要考虑代码的优雅性或最佳实践。
	\item \textbf{运行测试并成功：}确保所有测试（包括新添加的）都通过。
	\item \textbf{重构以消除重复：}在确保所有测试通过后，进行代码重构，以消除代码中的重复部分或提高代码质量。
\end{itemize}

\subsubsection{Martin的三个法则}

\begin{itemize}
	\item \textbf{不得编写生产代码，直到您编写了一个失败的单元测试：}这确保了对功能的期望在功能代码之前得到明确。
	\item \textbf{您不得编写超过足够导致失败的单元测试，且不编译也算作失败：}这避免了过度测试，鼓励开发者首先关注主要的失败点。
	\item \textbf{您不得编写超过足够通过当前失败测试的生产代码：}这强调了小步快跑，确保每一步都有明确的目标。
\end{itemize}

需要保持代码整洁，包括测试代码。代码的整洁性不仅使其易于阅读和维护，还可以避免将来的错误和复杂性。

\paragraph{测试驱动开发 (TDD) 并不是关于如何创建好的测试}
TDD的核心是关于如何设计和实现代码，而不仅仅是关于测试。虽然测试是TDD的关键组成部分，但TDD的真正价值在于它对软件开发生命周期的影响，以及它如何帮助开发者编写更好、更可维护的代码。

\paragraph{所有关于可维护代码的规则都适用于测试代码}
测试代码就像生产代码一样重要，它需要同样的注意力和照顾。考虑以下两个关键点：

\begin{itemize}
	\item \textbf{可理解性：}这是关于测试的明确性和目的。当其他开发者（或者您自己在未来）查看测试时，他们应该能够轻松地理解测试的目的，它测试了哪些功能，以及哪些测试与特定的代码段有关。

	\item \textbf{可变性：}当生产代码发生变化时，相关的测试可能也需要调整。开发者应该能够轻松识别哪些测试与特定代码段有关，以便在代码更改后更新或修改这些测试。
\end{itemize}

\paragraph{TDD不提供设计}尽管TDD鼓励良好的编程实践和重构，但它本身并不直接提供软件的设计或架构。设计和架构的质量依赖于开发者的经验和知识。

\paragraph{TDD $\neq$测试}TDD并不等于全面的测试。尽管TDD侧重于编写测试并确保代码按照测试的期望来实现，但进行适当的测试需要更多的测试用例。测试应当在API的级别。

我们并不总是明显的知道接下来应该写什么样的测试。在某些情况下，为了确定一个小的失败测试，可能需要添加已经通过的测试。如何进行最简单的更改以使测试通过并不总是明确的。这里的“最简单”可能会根据开发者的经验而有所变化。

识别存在哪些重复可能是困难的。那么，什么构成了“重复”呢？
“重复”包括“冗余/不必要的”和“数据重复”。
这似乎是进行“好的工程实践”的地方。
如何去除这种重复可能是困难的。
如果处理得不对，其后果是不明确的。但是，“回退”被视为一个可行的选项。

\paragraph{TDD是否排除了某些（好的）设计？}
例如，使用TDD可以得到雨量的过滤然后处理的设计吗？（循环是重复的吗？）

\section{相关研究}

一项研究涉及学生和工业团队，两者都有不同的控制水平。

TDD团队的特点：
更小的类和方法：与非TDD团队相比，使用TDD的团队倾向于编写更小的类和方法。这可能是因为TDD鼓励开发者频繁地进行小规模的迭代和改进。
更低的``复杂性"：TDD团队的软件复杂性较低。这可能意味着他们的代码更简洁、更容易理解和维护。
更低的``耦合" (CBO)：TDD团队的代码在CBO（类之间的耦合度）上得分较低。低耦合意味着各个组件或类之间的依赖关系更少，这可以增强软件的可维护性和灵活性。
``内聚" (LCOM5) 没有明显趋势：LCOM5是一个测量类内聚度的指标。在这项研究中，TDD与非TDD团队在内聚度上没有明显差异。

学生团队与工业团队的差异：
学生团队与工业团队之间在上述指标上的差异较大。特别是在工业团队中，使用TDD与否之间的差异较小。这可能是因为工业团队通常拥有更多的经验和培训，他们可能已经采用了其他的最佳实践，从而使TDD的效果相对较弱。

\section{总结}
TDD可带来我原本不会选择的成功设计。关于成本/效益权衡仍存在各种问题，但我更倾向于相信而非不相信。



































