\chapter{特别专题：评判可维护性的工具}

\section{评判可理解性的工具}

即使代码格式化得很好，变量和方法的命名也很贴切，但这并不能有效地帮助理解一个拥有上百万行（或者甚至上万行）的程序。为了更好地理解庞大的代码，一个通用的方法是创建工具，这些工具可以提供关注代码“重要”方面的视图。这意味着通过某种方式过滤或聚焦于代码的关键部分，而不是尝试一次性理解整个代码。

\subsubsection{具体方法}
\begin{itemize}
	\item 程序分析工具 (Program Analysis Tools): 这些工具可以自动分析代码，找出其中的模式、依赖关系和可能的问题点。例如，静态代码分析工具可以检测潜在的错误、安全性问题或不良的编码实践。
	\item 软件可视化工具 (Software Visualisation Tools): 这些工具将代码或其结构转化为图形或图像，以便于人类理解。例如，依赖关系图可以显示不同模块之间的依赖，而流程图可以显示程序的执行流程。
	\item 编程语言 (Programming Languages): 选择正确的编程语言或者利用语言的特定功能也可以帮助更好地理解程序。某些编程语言可能通过其设计或特性，如强类型、函数式编程或面向对象的特性，来促进更清晰、更模块化的代码。
\end{itemize}


\subsubsection{程序分析的重要性}
工具需要分析代码以确定感兴趣的属性。这种分析可以揭示代码的各种特征，从而帮助开发者更好地理解和优化代码。

\subsubsection{代码分析的步骤}
\begin{itemize}
	\item 解析代码: 工具首先需要读取并解析代码。
	\item 创建内部表示: 通常，工具会创建一个代码的内部表示，称为"抽象语法树"（AST）。
	\item 查找特征: 内部表示然后被检查，以找到感兴趣的特征。
\end{itemize}


\subsubsection{软件指标}
程序分析工具通常提供来自"软件指标"的测量，这些测量可以帮助评估代码的质量、效率和其他关键特性。

\subsubsection{实例分析}
以下是一些可能的研究或分析主题，其中包括了如何检测代码中的不良现象、开发者在命名、编码和决策中的实践等。
\begin{itemize}
	\item 代码的“坏味道”: 如何检测代码中可能存在的设计或实现问题。
	\item 命名规范的忽视: 开发者有多频繁地忽略了命名标识符的指南。
	\item 非有意义的命名: 开发者使用不具有明确意义的命名的频率。
	\item 函数/方法的参数数量: 开发者在他们创建的函数/方法中有多少参数。
	\item 记录不良决策: 开发者有多频繁地在代码中记录他们所做的不良决策（被称为"自承认的技术债务"）。
	\item 代码量的测量: “代码行数”是否提供与“方法数量”或“字段数量”不同的信息。
	\item 关注点的分离度量: 如何确定代码中"关注点分离"的程度。
\end{itemize}



\subsection{可视化工具}
软件可视化是软件工程领域中的一个大研究领域。例如，IEEE的VISSOFT工作会议专门研究软件可视化，这显示了这一主题的重要性和相关性。一幅画胜过千言万语" — 这句话表达了软件可视化的核心思想，即使用图片来有效地展示软件中的感兴趣方面。通过图像，我们可以更直观、更快速地理解复杂的概念或数据。

软件可视化强调了多个领域的结合，包括排版、平面设计、动画、电影摄影，以及现代的人机交互和计算机图形技术。这些结合在一起，目的是促进人们对计算机软件的理解和有效使用。

\subsection{City Metaphor}

“城市隐喻”旨在将软件系统视为一个城市。在这个城市中，建筑物代表类，不同的区域或社区代表软件包，而建筑物的大小、颜色和其他属性则代表软件的各种度量值。
例如，一个大型的建筑可能代表一个具有大量代码行数的类，而不同的颜色可能代表该类的复杂性或其他度量。

这个概念是由R. Wettel和M. Lanza在2007年的IEEE国际程序理解会议(ICPC '07)上首次提出的。
有研究表明，这种可视化方法有助于提高程序的理解。
在一个研究中，有41位参与者，其中一半使用这种可视化方法，另一半使用IDE（集成开发环境）。结果显示，使用这种可视化方法的参与者在效果和效率方面都有所提高。

通过将复杂的软件系统映射到更为直观和熟悉的城市模型上，开发者可以更容易地理解和探索其结构和属性。
这种方法提供了一个直观的、以用户为中心的界面，使开发者能够通过他们熟悉的方式（即探索一个城市）来探索和理解软件。

\subsection{Visualisations of object creation}

关于对象创建的可视化研究，这项研究的主要动机是，通过计算创建的对象数量，可以帮助确定一个类在多大程度上匹配其所代表的上下文模式概念。理解何时创建对象可能有助于更好地理解程序。这是因为对象的创建和初始化是大多数面向对象程序的核心部分，了解这些过程可以为分析和优化程序提供关键信息。Wang建立了一个工具，该工具可视化何时创建了哪些对象。这种可视化提供了一个直观的方式来观察和分析程序在运行时的行为，特别是关于对象创建和使用的模式。

Lucene是一个开源的Java应用程序，用于支持文本文件的高效搜索。
它的基本操作是对文件进行索引，然后支持对这些文件的搜索。
Lucene具有约720,400行代码，这使得理解其复杂的内部工作变得尤为重要。通过使用Wang的工具，开发者可以更容易地了解Lucene在运行时创建了哪些对象，以及这些对象是如何与整个系统交互的。

\subsection{Automated “Concept” Extraction (ACE)}

当人们试图理解大量的代码时，开发者会寻找他们认识的事物。他们通常寻找的方面有：
\begin{itemize}
	\item 设计（和架构）模式：常见的结构组织方式。
	\item 抽象：高级思想（通常来源于问题）。
	\item 跨抽象：出现在不同抽象中的特征。
	\item 跨包：出现在不同包中的特征。
\end{itemize}

开发者在一致的方式中使用有意义的名称。这意味着，代码中的命名应该可以为开发者提供有关代码功能和结构的线索。看到存在于这些不同“概念”之间的依赖关系可以帮助理解代码。例如，如果一个开发者可以识别出代码中的某些设计模式，他们就可以更快地理解代码的结构和功能，因为他们已经熟悉这些模式的典型用法和行为。

研究假设基于开发者始终使用有意义的命名，但这在现实中可能不总是如此。如果命名不一致或含糊不清，这可能会对ACE的有效性产生负面影响。

\subsubsection{工作流程}

\textbf{分解命名：}
这个过程首先要求将命名（可能是类、方法或变量的命名）分解为组成的“关键词”。例如，“InheritanceMatrixProcessorBuilder”被分解为“Inheritance”、“Matrix”、“Processor”和“Builder”。

\textbf{搜索继承层次顶部的类或接口：}
根据分解出的关键词，搜索处于继承层次顶部的类或接口。例如，从上面的例子中，会搜索与“Inheritance”、“Processor”和“Matrix”相对应的类或接口。

\textbf{查找多处出现的关键词：}
过程还涉及到搜索在多个位置出现的关键词，以确定哪些概念在不同的上下文中被重复使用。例如，“FilenameProcessorBuilder”和“InheritanceMatrixProcessorBuilder”中都有“ProcessorBuilder”。

\textbf{匹配已知模式的关键词：}
除了搜索常见关键词外，此过程还尝试匹配与已知模式（例如设计模式）对应的关键词。例如，“FilenameProcessorBuilder”和“InheritanceMatrixProcessorBuilder”可能与某些已知的设计模式相关。

\textbf{多重概念关键词：}
有些关键词可能表示多个概念。这意味着，单个关键词可能在不同的上下文中具有不同的含义或表示不同的事物。

\subsubsection{UML}

当试图理解面向对象设计时，重点通常放在“类”及其之间的关系上。方法和字段有时可能是重要的，但经常被忽略；实现完全不重要。UML主要展示类及其之间的关系，并可能显示一些字段和方法的信息。UML是一个可用于描述软件的视觉语言。与传统的编程语言不同，UML是图形化的，提供了对软件各个方面的视觉描述。

UML可以展示软件的多种视图，这是其强大之处。

静态视图：如类图，展示系统中的类、接口以及它们之间的关系。

动态视图：如序列图，展示对象之间随时间变化的互动。

用户视图：如用例图，展示用户与系统的交互。

软件与硬件的关系：如部署图，展示软件组件如何在硬件上进行分配。

UML确实提供了软件的可视化，但关键问题是：它是否真正帮助了用户更好地理解软件？
这是一个值得深入研究的问题，因为仅仅提供视觉表示可能不足以使复杂的系统变得容易理解。有效的UML图应该是简洁、清晰且有意义的，以促进对软件的深入理解。

\subsection{Remix}
Remix是一个试图提供更自然、直观语法的编程语言。Remix的主要目标是可读性，即使代码对于非程序员来说也应该是清晰易懂的。Remix使用标准的编译器技术来实现。
特别地，Remix使用了ANTLR，这是一个Java的解析器生成工具。
这意味着Remix在技术层面上并没有创新的部分，所使用的技术都是已经存在和广泛使用的。由于Remix使用的技术并不新颖，因此引发了一个问题：既然这样的技术已经存在，为什么我们迄今为止还没有类似的、更加易读的编程语言呢？虽然Remix的目标是增加代码的可读性，但是否它真的达到了这个目标，或者说是否它解决了所有与代码可读性相关的问题，仍然是一个待解决的问题。

\subsection{小结}
有一些支持理解代码的方法，并不一定要求代码是可理解的。但代码越易懂，支持效果就可能越好。软件可视化有助于理解代码的证据有限，也许需要这种支持就是承认我们编写的代码难以理解。


\section{综合评判可维护性的工具}
维护性是软件质量的重要方面，关注如何容易地对软件进行修改和更新。存在许多关于如何创建可维护软件的建议和指导。这可能包括代码规范、模块化设计、注释和文档的使用、避免使用复杂的代码结构等。已经提出了一些度量标准来衡量可能影响我们对维护性了解的某些软件属性。例如，代码复杂性、代码重复率、代码注释比例等，都可以为我们提供关于软件维护性的信息。

是否存在工具或方法，可以自动分析代码并为开发者提供关于其维护性的反馈呢？这种自动化工具可能会基于上述的度量标准来运行，为开发者提供维护性的评分或反馈，帮助他们识别可能的问题点并进行相应的改进。

\subsection{编译器}
一个编译器在编译一个程序时大致分为以下步骤：

\textbf{词法分析：}
它是编译过程的第一步。
主要任务是将源代码文本转化为“令牌”(tokens)序列。
这些令牌可以是关键词、变量名、常数、运算符等。
例如，将字符串``int a = 5;”分解为``int”、``a”、``=”和``5”这样的令牌。

\textbf{语法分析：}
也被称为解析。
使用上一步得到的令牌序列来创建一个抽象语法树(AST)。
AST代表了代码如何与编程语言的语法一致。
它表示了源代码的层次结构。

\textbf{语义分析：}
在这一步中，编译器会确定用到的标识符的含义。
这涉及到名字解析或类型解决，以确定变量或函数的类型、范围和绑定等。
例如，如果有一个变量声明为``int a”，那么编译器需要确保在其使用的地方，它被当作整数来处理。

\textbf{中间代码生成：}
将AST转化为中间代码的序列，这可能是字节码或其他形式的中间表示。
这个步骤使得编译器可以为多种目标架构生成代码，只需修改最后的代码生成步骤即可。

\textbf{优化：}
优化的目的是提高生成代码的性能，减少不必要的操作。
例如，编译器可能会识别到某些计算可以在编译时完成，而不是在运行时，从而提高运行时的性能。

\textbf{代码生成：}
这是编译过程的最后一步。
这一步将中间代码转换为最终形式，这通常是为特定硬件或运行时环境优化的机器代码。
结果是可以执行的机器代码或其他形式的目标代码。

\subsection{Automated Static Analysis Tools (ASAT)}

Automated Static Analysis Tools (ASAT)是一种工具，用于在没有实际执行程序的情况下分析源代码。
主要目的是确定代码是否与维护性的建议一致，并检查潜在的软件问题。

ASAT可以检查代码是否满足特定的编程建议和结构，例如：
\begin{itemize}
	\item 名称是否符合命名约定（例如Java的驼峰命名法）。
	\item 类的所有字段是否为抽象的，以支持依赖倒置原则(DIP)。
	\item 计算与其他类耦合的类的数量。
	\item 确定代码的循环复杂性。
\end{itemize}
这些分析类似于编译的语法和语义分析步骤。

一些分析形式需要更复杂的技术。例如：
\begin{itemize}
	\item 确定哪些变量未被初始化或使用。
	\item 识别可能出现NullPointerException的情况。
	\item 证明代码的“正确性”。
	\item 判断标识符是否“有意义”。
\end{itemize}


为了检测和修复潜在的代码问题，已经创建了许多工具来分析源代码，这些工具提供了关于代码是否存在潜在问题的评估。
这些工具通常称为自动静态分析工具（ASAT），它们为开发者提供了一个强大的手段，帮助他们编写更可靠、更高质量的代码，而不需要实际执行程序。

\subsection{ASAT Example: PMD}

PMD是一个代码分析工具，它提供了捕获可能指示代码问题的“规则集”。
它的目的是识别和报告违反指定规则的代码片段，从而帮助开发者改善代码质量。

PMD的规则可以配置，以适应特定的代码风格或项目需求。
用户还可以添加自定义的规则，这使得PMD更具灵活性，可以适应不同项目的特定需求。PMD假定分析的代码在语法上是正确的，但在语义上可能不正确。这意味着工具主要关注代码的结构和模式，而不是代码的实际执行或行为。尽管PMD主要用于Java代码，但它也支持多种编程语言。这使得开发者可以使用同一个工具分析多个项目，即使这些项目使用不同的编程语言。

PMD产生的报告会指出代码中违反指定规则的地方。这为开发者提供了一个清晰的指南，帮助他们识别和纠正潜在的代码问题。

PMD的规则集使用XML文档来指定。这意味着规则集的结构是有序和标准化的，可以方便地与其他工具或系统集成。

它们可以分为多个类别：
\begin{itemize}
	\item 遵循编码约定的规则：如ControlStatementBraces, ClassNamingConventions, MethodNamingConventions等。
	\item 针对命名选择的规则：如AvoidPrefixingMethodParameters, ShortClassName, ShortVariableName等。
	\item 试图捕获代码坏味道的规则：如GodClass和ExcessiveClassLength。
	\item 建议进行微小改进的规则：如ForLoopCanBeForeach, CollapsibleIfStatements, SimplifyBooleanExpressions等。
	\item 可能的错误：例如BrokenNullCheck。
	\item 基于某些经验法则的建议：如AvoidInstantiatingObjectsInLoops。
	\item 不是所有人都同意的规则：如OnlyOneReturn, AvoidReassigningParameters。
	\item 存在争议的规则：如AvoidInstantiatingObjectsInLoops, AbstractClassWithoutAbstractMethod。
	\item 特定于语言的规则：如JUnitAssertionsShouldIncludeMessage, ReplaceEnumerationWithIterator。
	\item 针对特定领域的规则：如AvoidUsingHardCodedIP, CheckResultSet。
\end{itemize}


某些规则是可以定制的，允许用户根据他们的具体需要对规则进行修改或调整。
例如，UnusedFormalParameter规则默认情况下仅报告私有方法的参数，但用户可以更改这一行为，可以改成所有方法。

许多PMD的规则（以及其他工具中使用的类似规则）都使用阈值来决定一个规则是否被违反。
这些阈值为编码实践提供了定量的标准，用于确定代码是否满足某些质量标准。
要有效使用PMD，开发者必须知道默认的阈值，并对其进行适当的评估。
一些默认的阈值可能是有争议的，这意味着这些值可能不适合所有的项目或团队。因此，开发者可能需要根据具体情境对其进行调整。

例如，一个名为ExcessiveClassLength的规则示例，该规则针对Java设计类别。
在这个规则中，属性minimum的值被设置为1000.0。这意味着，如果一个类的长度超过1000行，那么它就会被认为违反了这个规则。
这个默认的阈值可能会引起争议，因为不是所有的项目或团队都会同意1000行是一个类的“过长”标准。在某些场景下，一个包含多于1000行的类可能是完全合理的，而在其他场景下，可能只需要几百行。

\subsection{Understand (SciTools)}

``Understand”主要提供了各种可视化工具，包括饼状图、直方图、树状图等。这些可视化工具是基于各种度量的测量结果来生成的。通过这些可视化工具，开发者可以更直观地理解和分析软件的各种属性，从而更有效地进行软件开发和维护。

\subsection{SonarQube}

这是一个提供度量测量结果的工具，功能与“Understand”类似。
它也可以检查代码是否遵循某些编程规则，这点与PMD相似。

SonarQube声称它提供了``4800+的静态分析规则，覆盖了30种编程语言”。这说明它拥有广泛的规则库，并且支持多种编程语言。
SonarQube中的一些规则比PMD更为复杂。例如，它有一个规则是检查``方法的返回值不应该是不变的”。这意味着一个方法中的所有路径不应该都返回相同的值。
工具中的度量包括``代码异味”(Code Smells)和“可维护性评级”(Maintainability Rating)。

\section{总结}

工具旨在为可维护性评估提供自动化支持。在大多数情况下，它们要么提供可能有助于发现可维护性问题的测量指标，要么识别被认为会导致可维护性问题的代码特征。但是几乎没有科学证据表明它们值得付出代价（有些甚至是免费的）。
































