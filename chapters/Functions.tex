\chapter{Functions}

代码分解思想起源于1940年代或更早。这意味着，即使在计算机技术尚未普及，程序设计初期，这种方法已经开始受到认可。最初采用这种方法的目的是为了减少代码重复和内存使用。这可以理解为，早期计算机资源有限，因此节约内存和减少冗余是至关重要的。1960年代或更早，为了使代码更容易维护，开始有了将代码分解为单独可调用单元的想法，这一概念与“结构化编程”相对应。
结构化编程强调使用一种模块化、可预测的方式编写代码，使其易于阅读、维护和调试。这种思想与简单地节约资源或减少重复相比，更侧重于代码的清晰度和长期可维护性。它基本上是对“go to”语句的有纪律的使用。
结构化编程强加了关于代码组织方式决策的更多规律。如今的编程语言，如果有“go to”语句，只是以非常受限的形式存在，例如条件、循环语句。

结构化编程禁止在任何函数中有多于一个的返回。

\section{Functions should be}
小型（Small）：函数应该尽量小而简洁，这样更容易理解和维护。

做一件事（Do One Thing）：这也称为“内聚性”(cohesion)。一个函数只应该做一件事，并且做得好。

函数的每一层都应该有一个抽象层次（One Level of Abstraction per Function）：函数内部的所有语句都应该在同一层次的抽象上。这可以确保函数易于阅读和理解。

从上到下阅读代码（Reading Code from Top to Bottom）：函数的组织和呈现方式应该让读者能够从上到下顺畅地阅读。

使用描述性名称（Use Descriptive Names）：为函数选择有意义的名称，这样可以清楚地描述其功能和用途。

函数参数（Function Arguments）：函数的参数数量应该有限，每个参数都应有明确的目的。

没有副作用（Have No Side Effects）：函数不应该有任何意外的副作用，例如修改全局变量或更改传入的参数的状态。

为了获得高质量的函数：

首先避免问题（Avoid problems in the first place）：在编写代码时，一开始就遵循最佳实践，可以预防大多数问题。

如果出现问题，重构（If got problems, refactor）：重构是一种技术，通过修改代码以提高其质量，但不改变其功能。

Pro 单一返回： 单一退出点可以使函数的控制流更可预测，从而简化心智模型。
反对单一返回： 对于较长的函数来说，在末尾设置单一返回点可能会迫使读者在心智模型中保留更多的中间状态，从而使代码更难理解。
知识库：
支持单返回： 具有结构化编程背景的程序员或受过避免使用多返回语句训练的程序员可能会发现单返回点更直观。
反对单点返回： 现代编程教育通常会强调提前返回和保护子句以提高清晰度，因此有这种背景的程序员可能更喜欢多返回。
外部表示法：
支持单一返回： 单一返回可能会导致更少的分支和更线性的 ER，这可能更容易理解。
反对单返回： 单一返回的函数可能需要更深的嵌套或增加标志变量，这会使ER变得杂乱无章，难以理解。
同化过程：
支持单返回： 如果由于单返回而使控制流更具可预测性，则可能加快同化过程。
反对单一返回： 如果实现单一返回会使代码更加复杂，则可能会减慢同化过程。

\subsection{Self Documenting}
使用小的函数来创建自文档的代码。也需要避免使用字面量。

\subsection{每个函数应该维持一个抽象级别}
Martin建议避免在同一个函数中混合“高级”概念和“低级”概念。
这种混合可能会导致代码难以理解和维护，因为函数不再遵循“做一件事”的原则。

高级概念可能涉及领域的核心概念，如“更改网格中的单元格”。这些是更接近业务逻辑或任务的核心目标的代码段。
低级概念可能涉及实现细节，如“数组中的值表示什么”。这些是处理具体数据结构或操作系统调用等具体细节的代码段。

如果一个函数同时处理高级和低级概念，那么它可能在功能上太过复杂。
这使得函数更难测试，更难理解，也更难修改。

识别函数中各个部分的抽象级别可能是一个挑战。
一种可能的方法是使用缩进级别作为启发式方法来识别。这个方法的基本思路是：更多的缩进可能意味着更低的抽象级别。然而，这只是一个简化的方法，可能并不总是准确。
尽管Martin提倡每个函数只有一个抽象级别，但他没有明确地定义什么是一个“抽象级别”。这可能会导致一些歧义和困惑，因为不同的程序员可能对“抽象级别”的理解各不相同。一个可能的启发式是2个缩进就已经足够。

代码的可读性如何得到提高？
重构后的版本中，playerMove函数更加简洁。主要的改进是将玩家移动的合法性验证部分提取到一个新的函数playLegalMove中。这种模块化使函数的逻辑更清晰，也更符合“每个函数只做一件事”的原则。
代码的减少与理解性：
减少了一些重复和冗余的代码，从而使吸收过程需要的时间更少。
通过使用具有描述性的函数名（如playLegalMove），当该名称有意义时，访问心智模型更为高效。
代码的进一步重构：
虽然playLegalMove函数确实提高了playerMove的可读性，但它本身仍然有与原始playerMove相同的嵌套级别。这意味着可以考虑对playLegalMove进行进一步的重构。

如果一个函数只包含一个抽象级别，那么它很可能是一个小函数。这意味着它不会包含太多不同的逻辑或功能。但这不是绝对的，因为一个函数可能有一种可以利用的规律性，使其在短时记忆中的需求减少，即使它的长度超过了典型的“小函数”。

\subsection{自上而下阅读}
在新闻报道中，"倒金字塔"模型是指最重要和最基本的信息出现在文章的开头，而细节和补充信息随后出现。这种写作方式确保了读者即使只阅读文章的一部分，也可以获得核心信息。相似地，代码也可以被组织成这种层次结构，其中顶部函数是最抽象的，而底部函数是最具体的。

按照这种组织方式，代码的第一个函数提供了一个高层次的概述，其中大部分内容是对其他更具体函数的调用。这种组织结构有助于初次阅读代码的人快速地理解代码的主要目标和结构

这种从顶部到底部的代码阅读策略有助于提高效率。程序员可能只需要阅读顶部的函数就能获得足够的理解，而不必深入到每个具体的函数。这样，他们可以更快速地理解代码的主要逻辑和功能。

当程序员遇到一个函数调用时，他们知道从哪里开始查找它的声明。如果代码按照从抽象到具体的方式组织，那么函数的声明很可能紧跟在其调用的后面，这也提高了查找效率。

\subsection{Do One Thing}
\paragraph{内聚性}是指一个模块或函数在功能上的一致性。当说到一个函数具有高内聚时，意味着它只做一件事情，并且做得很好。高内聚有助于使代码更加模块化、可维护和可读。

很难具体量化一个函数到底在做多少件事情。但一个好的起始点是，尝试描述该函数的功能，如果在描述中出现了“和”或“或”这样的词，那么这个函数可能正在做多于一件的事情。

一个只做一件事的函数很可能是小的，因为它的功能被限定并集中于单一的目标。
大的方法或函数可能会涉及多个功能，从而降低其内聚性。

做单一功能的函数带来了多种优点。
在首次阅读时更容易理解，因为它的目的和功能是清晰和有限的。
当再次遇到该函数时，更容易回忆起它的功能，因为其功能是明确和唯一的，无论其实际大小如何。

\subsection{使用描述性的名称}
如果一个函数确实只做一件事情，那么它的名称应该清晰地描述出它的功能。这样，当其他开发者或未来的你自己再次查看代码时，可以快速地理解该函数的目的和功能，而无需深入其内部实现。

尽管在许多场景下，简短性可能是理想的，但当涉及到代码的清晰性和可读性时，长名称可能更为有利。如例子中所示，gameOverWithWinner() 和 gameOverWithDraw() 这样的名称比简短的名称更有描述性，能更快地传达函数的功能。

做单一功能的函数往往更容易命名。这是因为其功能是明确和限定的，所以为其选择一个准确的描述性名称相对更简单。
当函数具有多重功能或其功能不清晰时，为其选择一个准确、简短且描述性的名称可能会变得更加困难。




\subsection{小的函数}

函数大小的重要性：Martin的主张是，函数应该非常小。他甚至建议函数不应超过4行。这可能听起来很极端，但背后的逻辑是，更小的函数更容易理解，因为程序员只需要在短时间内关注一小部分的代码。这也使得函数更容易测试和维护。
这个建议与人的短期记忆能力有关。研究已经证明，人的短期记忆只能容纳有限的信息。这意味着，当一个函数或代码段太长时，要理解它的所有部分，程序员可能需要多次查看和思考。而小函数则更容易一次性理解。



\subsection{关于参数}
Martin关于函数参数数量的观点:

零个参数（zero arguments）：这是理想的情况，因为它意味着函数不需要外部信息来执行其任务。
一个参数（one argument）：这是可以接受的，但是要避免使用标志参数（flag arguments），因为它们会使函数的功能变得不明确。
两个参数（two arguments）：勉强可以接受。
三个参数（three arguments）：应尽量避免。
超过三个参数：这意味着函数可能在尝试做太多的事情，应该考虑重新设计或拆分。
输出参数（output arguments）：它们是待发生的问题，因为它们使函数有副作用，这可能会导致未预期的行为。

\subsubsection{为什么避免参数}

使用StringBuffer作为示例，Martin指出，如果我们把它作为参数传递，而不是作为字段（field），那么每次读到它时，读者都必须去解释它的含义。这增加了理解代码的难度。
当然，同样的问题也适用于字段。但字段通常更容易理解，因为它们在类或模块的范围内是已知的。
另外，从测试的角度看，参数更加困难。参数需要在每次调用时都进行设置，这可能会导致测试的复杂性增加。
然而，与参数相比，字段可能同样具有挑战性，或者更具挑战性。因为字段可以在类的多个地方被修改，这可能导致更多的不确定性和难以预测的行为。

\subsubsection{如何减少参数}
为减少函数参数数量而增加字段可能是一个糟糕的主意。字段存在是为了表示对象的状态。在面向对象编程中，对象的状态是由其字段来维护的。仅为了减少函数的参数数量而随意增加字段是不明智的。这可能导致对象状态的不必要复杂性，并可能违反了面向对象设计的原则，如封装。
如果增加字段并不真正代表对象的逻辑状态，那么这种做法可能会导致代码更难维护和理解。一个有关字段的启发式原则是：字段是否被公共函数（public function）所需要？这意味着如果一个字段只被私有方法使用，并且只是为了减少参数，那么它可能不是必要的。

参数对象是一种设计模式，它涉及到将多个参数封装成一个对象，从而减少函数的参数数量。这种方法在处理复杂函数和构造函数时尤为有用，特别是当它们需要多个参数时。
通过引入参数对象，可以简化函数签名，提高函数的可读性，并使得函数的调用更加直观。

有时，为参数创建一个明确的类并不是那么直观。例如，函数stillSearchingForFirstLetter接受三个整数参数，但并不清楚如何将它们组织成一个类或对象。
当函数的参数和逻辑不那么清晰时，这可能是一个设计或重构的迹象。即，这个函数可能需要进一步的思考，以确定其真正的目的和所需的参数。

\subsubsection{输出参数 Output Arguments}

函数修改了传入的参数，叫做输出参数。

Martin认为，输出参数可能会导致混淆，因为开发者通常不期望函数会改变传入参数的值。当函数修改其参数的值时，这可能会导致错误，特别是当开发者不清楚或不记得这一点时。

updateBoardWithMove函数中，参数houseChosenForMove的值被改变。虽然这种操作在技术上是容易实现的，但它可能会给读代码的人带来混淆。特别是当没有明确的文档或注释说明这一行为时。
然而，示例中的注释提到了houseChosenForMove的状态变化。这种注释的存在可能暗示了该函数存在设计上的问题。通常，如果一个函数的行为需要通过注释来解释，那么这可能是一个信号，表明这个函数的设计和行为可能需要进一步的优化。


\subsubsection{与PCM结合}
程序理解模型通常包括几个组件，如Mental Model (MM)，Knowledge Base (KB)，External Representation (ER) 和Assimilation Process。多个参数可能会影响这个模型中的Assimilation Process部分。
当一个函数有多个参数时，开发者需要在心智模型中跟踪这些参数和它们的交互，这可能会使代码更难理解。
多个参数意味着开发者在阅读和理解代码时需要在KB和ER之间进行更多的切换，这可能会降低效率。
总之，根据程序理解模型，多个参数可能会使代码的理解变得更加困难和低效。

\subsubsection{平衡参数数量}
我们可以看到参数对于函数的重要性以及过多参数带来的问题之间存在明显的矛盾。如何平衡这两个方面？

精确使用参数：确保每个参数在函数中都有明确的目的。避免添加不必要的参数。

参数组织：对于接受多个相关参数的函数，考虑使用对象或结构来组织这些参数，从而将它们组合为一个参数。

使用默认参数和函数重载：在某些编程语言中，可以使用默认参数或函数重载来为不同的使用情况提供不同的参数集，从而在不牺牲功能的情况下减少参数数量。

参数注释和命名：确保参数有描述性的名称并适当地注释，以提高其可读性和理解性。

\section{不要重复自己 DRY}
DRY原则是一种编程哲学，旨在减少重复的代码。重复的代码不仅导致代码膨胀，还可能导致维护上的问题。当一段代码被复制到多个地方，任何对该代码的修改都必须在所有地方进行，否则可能会导致不一致和错误。

代码重复通常会降低代码的可维护性。例如，如果开发者需要修改重复的代码，他们必须找到并修改代码的每一个实例，这会消耗更多的时间和精力。
当开发者需要阅读或理解代码时，重复的代码片段可能会造成困托。不必要地阅读相同的代码片段会浪费时间，并可能导致误解，尤其是当上下文略有不同时。

如果其中一个重复的代码片段发生变化，而其他地方的相同代码没有相应地改变，那么这可能会导致未预期的行为和错误。因此，即使初始的代码复制可能是出于快速实现的目的，但长期看来，这种做法可能会带来更多的问题。

删除重复的代码很可能会减少相关方法的大小。小型、简洁的方法更容易阅读和维护，这也符合之前讨论的关于方法应该小且只做一件事的原则。

\section{小函数真的利于维护吗}
小函数可以使代码更容易读懂和维护，因为它们通常关注于单一的功能或任务。但同时，太多的小函数可能导致难以追踪和管理。

编写小函数确实有成本，特别是当将大型方法分解为多个小型方法时。必须权衡这一过程的利与弊。例如，一个小函数可以提高代码的可读性，但同时也可能增加代码的复杂性，因为需要跳转到多个地方才能完全理解一个功能是如何实现的。

添加更多的小函数有时可以减少代码量，尤其是当它们能够消除重复代码时。然而，每个函数都有其开销（例如定义、注释、调用等），所以在某些情况下，增加更多的函数实际上可能会增加代码量。

Martin的建议基于经验，可以看作是一套启发式规则。而不是盲目地应用这些启发式方法，更重要的是理解它们为什么以及在哪些情况下有效。也就是说，应当理解每个建议背后的原因，以便在合适的情境下使用它。

\subsection{与PCM结合}
1. 提高代码的清晰度和可读性（Assimilation Process）:

小函数一般都是围绕着一个特定的任务或功能。这使得开发者在通过ER理解代码时，可以更快速地将其与KB中的相关知识模式匹配，从而更快地形成MM。

2. 强化心智模型的清晰度（MM）：

当每个函数都专注于一个单一任务时，MM变得更加清晰。开发者不需要花费大量的时间和精力去理解复杂的、执行多个任务的函数，这也可以帮助他们更好地预测程序的行为。

3. 减少认知负担：

在ER中，小函数的名称，如果命名得当，可以直接告诉开发者函数的目的和功能。这种自文档化的代码减少了从ER到MM的转化所需的努力。

4. 长期维护的价值：

当代码需要修改或扩展时，小函数提供了明确的界定，使开发者更容易确定哪部分代码需要修改。此外，它还可以减少出错的机会，因为修改的范围通常更小、更集中。
由于小函数的目的明确，它们也更容易被测试，从而增加了代码质量。

结论：
小函数确实可以使程序更容易理解，它们提供了明确的上下文，有助于开发者构建和维护心智模型。从长期的角度看，小函数确实为程序的维护带来了价值，特别是在团队环境中，它们有助于新成员快速地理解和参与到项目中。

\section{总结}
许多小的高质量函数可以帮助理解：
小函数的主要优势在于它们可以更明确地表达代码的意图。一个有描述性的函数名可以快速地告诉开发者该函数的功能，从而使代码自我说明。
例如，一个名为calculateTotalAmount()的函数可能比一个简单名为calculate()的函数更具描述性。后者可能需要查看函数的内部实现或调用上下文才能理解它的真正功能。

抽象级别的考虑：
当在阅读代码时，开发者可能不需要关心那些低抽象级别的功能（也就是更具体或低级别的操作）。这意味着，他们可以专注于高级逻辑，而不是被困在细节中。
这进一步减少了频繁参考外部表示（例如函数的具体实现或其他文档）的需要。从而可以更快速、高效地理解代码的主要逻辑和结构。

重构以改进函数的使用：
重构不仅仅是为了修复错误，它也是一个使代码更加整洁、更具可读性和可维护性的过程。
为了提高函数的效用，有时可能需要对现有的函数进行拆分、合并或重命名等重构操作。

分步进行重构：
在实际编程中，很少有一步到位的重构。相反，开发者通常会分多个小步骤进行重构，确保每一步都不会破坏现有的功能。
这种分步的方法还允许开发者在每一步都进行测试，确保代码的功能性不受影响。

使用许多优秀的小函数可以帮助理解（至少）。
因为它们的名称表明了它们所做的一件事（自文档化代码！）。
通常不需要考虑抽象程度较低的函数。
通常不需要考虑抽象程度较低的函数、
我们没有可靠的方法来确定大多数建议的成本效益比。